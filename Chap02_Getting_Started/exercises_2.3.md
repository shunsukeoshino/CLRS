## 2.3 アルゴリズムの設計

### 2.3-1
***
> 図2.4を手本にして, 配列 $A =〈3,41,52,26,38,57,9,49〉$ 上のマージソートの動作を図示せよ. 


```python
def Merge(A, p, q, r):
    L = A[p:q+1] + [100000] # 番兵
    R = A[q+1:r+1] + [100000] # 番兵
    print('----------------------------------')
    print(A[p:q+1] , A[q+1:r+1]) # マージ前
    
    i = 0
    j = 0
    for k in range(p, r+1):
        if L[i] < R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            
    print('↓MERGE↓')
    print(A[p:q+1] + A[q+1:r+1]) # マージ後
    

def Merge_sort(A, p, r):
    if p < r:
        q = (p+r) // 2
        Merge_sort(A, p, q)        
        Merge_sort(A, q+1, r)
        Merge(A, p, q, r)
```


```python
A = [3, 41, 52, 26, 38, 57, 9, 49]
print(A)
Merge_sort(A, 0, len(A)-1)
```

    [3, 41, 52, 26, 38, 57, 9, 49]
    ----------------------------------
    [3] [41]
    ↓MERGE↓
    [3, 41]
    ----------------------------------
    [52] [26]
    ↓MERGE↓
    [26, 52]
    ----------------------------------
    [3, 41] [26, 52]
    ↓MERGE↓
    [3, 26, 41, 52]
    ----------------------------------
    [38] [57]
    ↓MERGE↓
    [38, 57]
    ----------------------------------
    [9] [49]
    ↓MERGE↓
    [9, 49]
    ----------------------------------
    [38, 57] [9, 49]
    ↓MERGE↓
    [9, 38, 49, 57]
    ----------------------------------
    [3, 26, 41, 52] [9, 38, 49, 57]
    ↓MERGE↓
    [3, 9, 26, 38, 41, 49, 52, 57]


### 2.3-2
***
> 手続きMERGEを番兵を使わないように書き直せ. 代わりに, LかRのどちらかですべての要素がAに書き戻されたら直ちに停止し, 他方に残されている要素をAに書き戻すようにせよ. 


```python
def Merge(A, p, q, r):
    L = A[p:q+1]
    R = A[q+1:r+1]
    print('----------------------------------')
    print(A[p:q+1] , A[q+1:r+1]) # マージ前
    
    i = 0
    j = 0
    for k in range(p, r+1):
        if len(L) == i: # iはLの要素を参照するためのインデックスであるため、この条件でLの全ての要素がAに書かれたと判断できる
            A[k:r+1] = R[j:]
            break
            
        if len(R) == j: # jはRの要素を参照するためのインデックスであるため、この条件でRの全ての要素がAに書かれたと判断できる
            A[k:r+1] = L[i:]
            break
            
        if L[i] < R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            
    print('↓MERGE↓')
    print(A[p:q+1] + A[q+1:r+1]) # マージ後
    

def Merge_sort(A, p, r):
    if p < r:
        q = (p+r) // 2
        Merge_sort(A, p, q)        
        Merge_sort(A, q+1, r)
        Merge(A, p, q, r)
```


```python
A = [3, 41, 52, 26, 38, 57, 9, 49]
print(A)
Merge_sort(A, 0, len(A)-1)
```

    [3, 41, 52, 26, 38, 57, 9, 49]
    ----------------------------------
    [3] [41]
    ↓MERGE↓
    [3, 41]
    ----------------------------------
    [52] [26]
    ↓MERGE↓
    [26, 52]
    ----------------------------------
    [3, 41] [26, 52]
    ↓MERGE↓
    [3, 26, 41, 52]
    ----------------------------------
    [38] [57]
    ↓MERGE↓
    [38, 57]
    ----------------------------------
    [9] [49]
    ↓MERGE↓
    [9, 49]
    ----------------------------------
    [38, 57] [9, 49]
    ↓MERGE↓
    [9, 38, 49, 57]
    ----------------------------------
    [3, 26, 41, 52] [9, 38, 49, 57]
    ↓MERGE↓
    [3, 9, 26, 38, 41, 49, 52, 57]


### 2.3-3
***
> nが2のベキ乗のとき, 漸化式
> 
> $T(n)=\left\{\begin{matrix}2 & \text{n=2のとき}\;  \\\\ 2T(n/2) + n & \text{k>1に対して}\; n = 2^k \text{のとき}\;\end{matrix}\right.$
> 
> の解が $T(n)=n\lg n$. であることを数学的帰納法を用いて示せ. 

数学的帰納法を用いて証明するプロセスは以下のように進められます：

- **ベースケース**:
  - $k=1$ のとき、$n=2$ で、$T(2) = 2 = 2 \log 2$ より成立します。

- **帰納仮定**:
  - $k=i$ のとき、$n=2^i$ で $T(2^i) = 2^i \log 2^i = i 2^i$ の成立を仮定します。

- **帰納ステップ**:
  - $k=i+1$ のとき、$n=2^{i+1}$ で $T(2^{i+1}) = 2T(2^i) + 2^{i+1} = i 2^{i+1} + 2^{i+1} = (i+1) 2^{i+1} = 2^{i+1} \log 2^{i+1}$ より成立します。

したがって、数学的帰納法により示すことができました。

### 2.3-4
***
> 挿入ソートは再帰的手続きとしても表現できる. $A[1 .. n]$ をソートするには再帰的に $A[1 .. n-1]$ をソートし, 次に $A[n]$ 叫をソート済みの配列 $A[1 .. n-1]$ に挿入すればよい. 再帰版の挿入ソートの最悪実行時間に対する漸化式を書け. 


```python
def recursive_Insertion_sort(A, i, n): # サブリスト`A[0…i-1]`はソート済みとして、A[i]をソート済みのリストに挿入する
    key = A[i]
    j = i

    while j > 0 and A[j-1] > key:
        A[j] = A[j-1]
        j -= 1
    A[j] = key

    if i < n:
        recursive_Insertion_sort(A, i+1, n)
```


```python
A = [3, 41, 52, 26, 38, 57, 9, 49]
recursive_Insertion_sort(A, 0, len(A)-1)
print(A)
```

    [3, 9, 26, 38, 41, 49, 52, 57]


* 再帰的な挿入ソートでは、特定の位置`i`から要素を正しい位置に挿入する処理が含まれています。最悪の場合（リストが降順にソートされている場合）の実行時間を考えると、各ステップで`i`番目の要素をその正しい位置まで移動させるのに最大`i-1`回の比較が必要になります。

* このアルゴリズムの実行時間の漸化式を考えると、次のように表現されます：
$$ T(n) = T(n-1) + n - 1 $$
ここで、$T(n-1)$は$n-1$要素のリストをソートするのに必要な時間、そして$n-1$は$n$番目の要素を適切な位置に挿入するために必要な最大の比較回数です。

* この漸化式の解を求めると、
$$ T(n) = 1 + 2 + \dots + (n - 1) $$
となり、これは等差数列の和であり、その和は
$$ T(n) = \frac{(n-1) \cdot n}{2} $$
と計算できます。これは$O(n^2)$の計算量を示しています。

### 2.3-5
***
> 探索問題(練習問題2.1-3を参照せよ)に戻って, 列 $A$ がソートされていれば, この列の中央値を $v$ と比較することで列の半分を以降の探索範囲から除去できる. 2分探索(binarysearch)はこの手続きを繰り返し, 繰返しのたびに残された列の長さを半減する. 2分探索(繰返し型と再帰型のどちらでもよい)の擬似コードを書け. 2分探索の最悪実行時間が $\Theta(\lg n)$ であることを示せ. 


```python
def Binary_search(A, v): # 繰返し型の2分探索
    left_index = 0
    right_index = len(A)-1
    mid_index = (right_index + left_index)//2
    
    while left_index < right_index:
        if v == A[mid_index]:
            return mid_index
            break
            
        elif v < A[mid_index]:
            right_index = mid_index
            mid_index = (right_index + left_index)//2
            
        elif v > A[mid_index]:
            left_index = mid_index + 1
            mid_index = (right_index + left_index)//2
        
    else:
        return 'NIL'
```


```python
Binary_search(A, 41)
```




    4



* 2分探索を1回実行すると、配列は半分のサイズになります。したがって、n個の要素を持つ配列での探索にかかる時間は、半分のサイズの配列での探索時間に1回の比較時間（これは定数時間であると見なせます）を加えたものに等しくなります。これを数式で表すと、以下のような漸化式が成り立ちます。

$$
T(n) = T\left(\frac{n}{2}\right) + c
$$

* ここで、$c$ は定数で、中間値と探索値を比較するのにかかる時間です。

* 上記の計算から、2分探索の実行時間 $T(n)$ は $\lg n$ に比例します。よって、2分探索の最悪実行時間は $\Theta(\lg n)$ となることが示されました。
