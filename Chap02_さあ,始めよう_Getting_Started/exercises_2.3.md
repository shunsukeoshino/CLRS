## 2.3 アルゴリズムの設計

### 2.3-1
***
> 図2.4を手本にして, 配列 $A =〈3,41,52,26,38,57,9,49〉$ 上のマージソートの動作を図示せよ. 


```python
def Merge(A, p, q, r):
    L = A[p:q+1] + [100000] # 番兵
    R = A[q+1:r+1] + [100000] # 番兵
    print('----------------------------------')
    print(A[p:q+1] , A[q+1:r+1]) # マージ前
    
    i = 0
    j = 0
    for k in range(p, r+1):
        if L[i] < R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            
    print('↓MERGE↓')
    print(A[p:q+1] + A[q+1:r+1]) # マージ後
    

def Merge_sort(A, p, r):
    if p < r:
        q = (p+r) // 2
        Merge_sort(A, p, q)        
        Merge_sort(A, q+1, r)
        Merge(A, p, q, r)
```


```python
A = [3, 41, 52, 26, 38, 57, 9, 49]
print(A)
Merge_sort(A, 0, len(A)-1)
```

    [3, 41, 52, 26, 38, 57, 9, 49]
    ----------------------------------
    [3] [41]
    ↓MERGE↓
    [3, 41]
    ----------------------------------
    [52] [26]
    ↓MERGE↓
    [26, 52]
    ----------------------------------
    [3, 41] [26, 52]
    ↓MERGE↓
    [3, 26, 41, 52]
    ----------------------------------
    [38] [57]
    ↓MERGE↓
    [38, 57]
    ----------------------------------
    [9] [49]
    ↓MERGE↓
    [9, 49]
    ----------------------------------
    [38, 57] [9, 49]
    ↓MERGE↓
    [9, 38, 49, 57]
    ----------------------------------
    [3, 26, 41, 52] [9, 38, 49, 57]
    ↓MERGE↓
    [3, 9, 26, 38, 41, 49, 52, 57]


### 2.3-2
***
> 手続きMERGEを番兵を使わないように書き直せ. 代わりに, LかRのどちらかですべての要素がAに書き戻されたら直ちに停止し, 他方に残されている要素をAに書き戻すようにせよ. 


```python
def Merge(A, p, q, r):
    L = A[p:q+1]
    R = A[q+1:r+1]
    print('----------------------------------')
    print(A[p:q+1] , A[q+1:r+1]) # マージ前
    
    i = 0
    j = 0
    for k in range(p, r+1):
        if len(L) == i: # iはLの要素を参照するためのインデックスであるため、この条件でLの全ての要素がAに書かれたと判断できる
            A[k:r+1] = R[j:]
            break
            
        if len(R) == j: # jはRの要素を参照するためのインデックスであるため、この条件でRの全ての要素がAに書かれたと判断できる
            A[k:r+1] = L[i:]
            break
            
        if L[i] < R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            
    print('↓MERGE↓')
    print(A[p:q+1] + A[q+1:r+1]) # マージ後
    

def Merge_sort(A, p, r):
    if p < r:
        q = (p+r) // 2
        Merge_sort(A, p, q)        
        Merge_sort(A, q+1, r)
        Merge(A, p, q, r)
```


```python
A = [3, 41, 52, 26, 38, 57, 9, 49]
print(A)
Merge_sort(A, 0, len(A)-1)
```

    [3, 41, 52, 26, 38, 57, 9, 49]
    ----------------------------------
    [3] [41]
    ↓MERGE↓
    [3, 41]
    ----------------------------------
    [52] [26]
    ↓MERGE↓
    [26, 52]
    ----------------------------------
    [3, 41] [26, 52]
    ↓MERGE↓
    [3, 26, 41, 52]
    ----------------------------------
    [38] [57]
    ↓MERGE↓
    [38, 57]
    ----------------------------------
    [9] [49]
    ↓MERGE↓
    [9, 49]
    ----------------------------------
    [38, 57] [9, 49]
    ↓MERGE↓
    [9, 38, 49, 57]
    ----------------------------------
    [3, 26, 41, 52] [9, 38, 49, 57]
    ↓MERGE↓
    [3, 9, 26, 38, 41, 49, 52, 57]


### 2.3-3
***
> nが2のベキ乗のとき, 漸化式
> 
> $T(n)=\left\{\begin{matrix}2 & \text{n=2のとき}\;  \\ 2T(n/2) + n & \text{k>1に対して}\; n = 2^k \text{のとき}\;\end{matrix}\right.$
> 
> の解が $T(n)=n\lg n$. であることを数学的帰納法を用いて示せ. 

数学的帰納法を用いて証明するプロセスは以下のように進められます：

- **ベースケース**:
  - $k=1$ のとき、$n=2$ で、$T(2) = 2 = 2 \log 2$ より成立します。

- **帰納仮定**:
  - $k=i$ のとき、$n=2^i$ で $T(2^i) = 2^i \log 2^i = i 2^i$ の成立を仮定します。

- **帰納ステップ**:
  - $k=i+1$ のとき、$n=2^{i+1}$ で $T(2^{i+1}) = 2T(2^i) + 2^{i+1} = i 2^{i+1} + 2^{i+1} = (i+1) 2^{i+1} = 2^{i+1} \log 2^{i+1}$ より成立します。

したがって、数学的帰納法により示すことができました。

### 2.3-4
***
> 挿入ソートは再帰的手続きとしても表現できる. $A[1 .. n]$ をソートするには再帰的に $A[1 .. n-1]$ をソートし, 次に $A[n]$ 叫をソート済みの配列 $A[1 .. n-1]$ に挿入すればよい. 再帰版の挿入ソートの最悪実行時間に対する漸化式を書け. 


```python
def recursive_Insertion_sort(A, i, n): # サブリスト`A[0…i-1]`はソート済みとして、A[i]をソート済みのリストに挿入する
    key = A[i]
    j = i

    while j > 0 and A[j-1] > key:
        A[j] = A[j-1]
        j -= 1
    A[j] = key

    if i < n:
        recursive_Insertion_sort(A, i+1, n)
```


```python
A = [3, 41, 52, 26, 38, 57, 9, 49]
recursive_Insertion_sort(A, 0, len(A)-1)
print(A)
```

    [3, 9, 26, 38, 41, 49, 52, 57]


* 再帰的な挿入ソートでは、特定の位置`i`から要素を正しい位置に挿入する処理が含まれています。最悪の場合（リストが降順にソートされている場合）の実行時間を考えると、各ステップで`i`番目の要素をその正しい位置まで移動させるのに最大`i-1`回の比較が必要になります。

* このアルゴリズムの実行時間の漸化式を考えると、次のように表現されます：
$$ T(n) = T(n-1) + n - 1 $$
ここで、$T(n-1)$は$n-1$要素のリストをソートするのに必要な時間、そして$n-1$は$n$番目の要素を適切な位置に挿入するために必要な最大の比較回数です。

* この漸化式の解を求めると、
$$ T(n) = 1 + 2 + \dots + (n - 1) $$
となり、これは等差数列の和であり、その和は
$$ T(n) = \frac{(n-1) \cdot n}{2} $$
と計算できます。これは$O(n^2)$の計算量を示しています。

### 2.3-5
***
> 探索問題(練習問題2.1-3を参照せよ)に戻って, 列 $A$ がソートされていれば, この列の中央値を $v$ と比較することで列の半分を以降の探索範囲から除去できる. 2分探索(binarysearch)はこの手続きを繰り返し, 繰返しのたびに残された列の長さを半減する. 2分探索(繰返し型と再帰型のどちらでもよい)の擬似コードを書け. 2分探索の最悪実行時間が $\Theta(\lg n)$ であることを示せ. 


```python
def Binary_search(A, v): # 繰返し型の2分探索
    left_index = 0
    right_index = len(A)-1
    mid_index = (right_index + left_index)//2
    
    while left_index < right_index:
        if v == A[mid_index]:
            return mid_index
            break
            
        elif v < A[mid_index]:
            right_index = mid_index
            mid_index = (right_index + left_index)//2
            
        elif v > A[mid_index]:
            left_index = mid_index + 1
            mid_index = (right_index + left_index)//2
        
    else:
        return 'NIL'
```


```python
Binary_search(A, 41)
```




    4



* 2分探索を1回実行すると、配列は半分のサイズになります。したがって、n個の要素を持つ配列での探索にかかる時間は、半分のサイズの配列での探索時間に1回の比較時間（これは定数時間であると見なせます）を加えたものに等しくなります。これを数式で表すと、以下のような漸化式が成り立ちます。

$$
T(n) = T\left(\frac{n}{2}\right) + c
$$

* ここで、 $c$ は定数で、中間値と探索値を比較するのにかかる時間です。

* 上記の計算から、2分探索の実行時間 $T(n)$ は $\lg n$ に比例します。よって、2分探索の最悪実行時間は $\Theta(\lg n)$ となることが示されました。

### 2.3-6
***
> 2.1節で示したINSERTION-SORT手続きの第5~7行のwhile文では, ソート済み部分配列 $A[1..j-1]$ の(逆向き)走査に順次探索を用いた. 順次探索の代わりに2分探索(練習問題2.3-5を参照せよ)を用いて挿入ソートの最悪実行時間を $\Theta(n\lg n)$ に改善できるか?

与えられた挿入ソートのアルゴリズムを、通常の線形探索ではなく、二分探索を使用して要素を挿入する位置を見つけるように変更することが求められています。二分探索を用いることで、配列の検索部分の時間複雑度を $\Theta(n\lg n)$ から $\Theta(\lg n)$ に改善できますが、全体の時間複雑度は移動に $\Theta(n)$ が必要なため $\Theta(n^2)$ には変わりませんが、ある程度の改善が見込めます。


```python
def Binary_search(A, key, start, end):
    if start >= end:
        return start if A[start] > key else start + 1
    mid = (start + end) // 2
    if key < A[mid]:
        return binary_search(A, key, start, mid-1)
    elif key > A[mid]:
        return binary_search(A, key, mid + 1, end)
    else:
        return mid

def Insertion_sort_with_binary_search(A):
    for j in range(1, len(A)):
        key = A[j]
        # ソートされた部分に対して二分探索を用いて挿入位置を見つける
        insertion_index = binary_search(A, key, 0, j - 1)
        
        # 挿入位置まで要素を右にシフトする
        i = j
        while i > insertion_index:
            A[i] = A[i-1]
            i -= 1
        A[insertion_index] = key
        
        # 各ループの最後に挿入したkeyの値と挿入後の配列Aを表示
        print('key =', key, A)
```


```python
# 例として、この関数をテストするための簡単な配列
test_array = [9, 3, 7, 5, 6, 2, 8]
insertion_sort_with_binary_search(test_array)
```

    key = 3 [3, 9, 7, 5, 6, 2, 8]
    key = 7 [3, 7, 9, 5, 6, 2, 8]
    key = 5 [3, 5, 7, 9, 6, 2, 8]
    key = 6 [3, 5, 6, 7, 9, 2, 8]
    key = 2 [2, 3, 5, 6, 7, 9, 8]
    key = 8 [2, 3, 5, 6, 7, 8, 9]


### 2.3-7
***
> ★ $n$ 個の整数の集合 $S$ とある整数 $x$ が与えられたとき, $S$ の中の2個の要素で, それらの和がちょうど $x$ になるものが存在するかどうかを決定する $\Theta(n\lg n)$ 時間アルゴリズムを記述せよ. 


```python
def Binary_search_for_two_sum(S, x):
    left_index = 0
    right_index = len(A)-1
    
    while left_index < right_index:
        if S[left_index] + S[right_index] == x:
            return True
            
        elif S[left_index] + S[right_index] < x:
            left_index += 1
            
        elif S[left_index] + S[right_index] > x:
            right_index -= 1
            
    return False
```


```python
A = [3, 41, 52, 26, 38, 57, 9, 49]
Merge_sort(A, 0, len(A)-1)
Binary_search_for_two_sum(A, 12)
```

    ----------------------------------
    [3] [41]
    ↓MERGE↓
    [3, 41]
    ----------------------------------
    [52] [26]
    ↓MERGE↓
    [26, 52]
    ----------------------------------
    [3, 41] [26, 52]
    ↓MERGE↓
    [3, 26, 41, 52]
    ----------------------------------
    [38] [57]
    ↓MERGE↓
    [38, 57]
    ----------------------------------
    [9] [49]
    ↓MERGE↓
    [9, 49]
    ----------------------------------
    [38, 57] [9, 49]
    ↓MERGE↓
    [9, 38, 49, 57]
    ----------------------------------
    [3, 26, 41, 52] [9, 38, 49, 57]
    ↓MERGE↓
    [3, 9, 26, 38, 41, 49, 52, 57]





    True


