### 2-1 マージソートに現れる小配列上の挿入ソート

***

> マージソートの最悪実行時間は $\Theta(n\lg n)$ ,挿入ソートの最悪実行時間は $\Theta(n^2)$ であるが,挿入ソートのほうが定数因子が小さいので,問題サイズが小さいときには挿入ソートのほうが多くの計算機上で高速に実行できる. そこで,部分問題が十分小さくなったときに,マージソートの中で挿入ソートを用いて再帰の底を上げる(coarsentheleaves)意義がある. $n/k$ 個のそれぞれ長さ $k$ の部分リストを挿入ソートを用いてソートし, その後は標準的な方法でマージを行うようにマージソートを改良する. 
> 
> __*a*__.  $n/k$ 個のそれぞれ長さ $k$ の部分リストは, 挿入ソートにより最悪時に $\Theta(nk)$ 時間でソートできることを示せ. 

* 挿入ソートの最悪実行時間は、配列の長さを $m$ としたとき $\Theta(m^2)$ です。各部分リストの長さが $k$ で、これらのリストが $n/k$ 個ある場合、各リストのソート時間は $\Theta(k^2)$ です。全てのリストをソートする総時間は、それぞれのリストのソート時間を合計したものになります。

$$
\text{全リストのソート時間} = \frac{n}{k} \times \Theta(k^2) = \Theta(nk)
$$

> __*b*__. ソート済みの $n/k$ 個の部分リストは最悪時に $\Theta(n\lg(n/k))$ 時間でマージできることを示せ.

* $n/k$ 個のソート済みリストをマージする際の時間は、マージソートのマージ段階と同様に、各段階で全要素数 $n$ を操作し、段階数が $\lg(n/k)$ であるため、次のように計算できます。

$$
\text{マージ時間} = n \times \lg\left(\frac{n}{k}\right) = \Theta\left(n \lg\left(\frac{n}{k}\right)\right)
$$

> __*c*__. 改良アルゴリズムの最悪実行時間を $\Theta(nk+n\lg(n/k))$ とする. 改良アルゴリズムが標準的なマージソートと同じ漸近的実行時間を持つという条件の下で, $k$ が取りうる最大値を $n$ の関数として $\Theta$ 記法で示せ.

* 問題文から、改良アルゴリズムの最悪実行時間は $\Theta(nk + n \lg(n/k))$ です。標準のマージソートの実行時間が $\Theta(n \lg n)$ であるため、これと等しい条件で $k$ の最大値を求めます。

$$
nk + n \lg\left(\frac{n}{k}\right) = n \lg n
$$

* 最もバランスの良い場合（つまり、挿入ソートとマージのコストが同等になる場合）は、 $nk$ と $n \lg(n/k)$ のオーダーが等しくなるような $k$ を見つけます。これは以下のように導出されます。

$$
k = \lg\left(\frac{n}{k}\right)
$$

を解いて、

$$
k = \Theta(\lg n)
$$

が得られます。

> __*d*__. 実際的には $k$ の値をどのように選ぶべきか?

* 実際に $k$ の値を選ぶ際には、以下の点を考慮する必要があります。

* 小さな $k$ は挿入ソートの効率を高めるが、マージの回数が増えてしまう。
* 大きな $k$ はマージの回数を減らすが、それぞれの挿入ソートのコストが増大する。

* 一般的に、挿入ソートの定数時間の低さを活かし、計算機のキャッシュ効果も考慮に入れて、小さな $k$ （例えば、 $k \approx \lg n$ から $k \approx \sqrt{n}$ くらい）を選ぶのが良いでしょう。ただし、実際の値は具体的な環境やデータの特性により異なるため、実験的に最適な値を見つけることが推奨されます。

### 2-2 バブルソートの正当性

***

> バブルソートは人気があるが，非効率なソーティングアルゴリズムである. バブルソートは隣接要素が逆順になっていれば，それらの位置を交換する操作を繰り返すことでソートを実現する.

```
BUBBLESORT(A)
1 for i= 1 to A.length - 1
2     for j = A.length downto i + 1
3         if A[j] < A[j - 1]
4             exchange A[j] with A[j - 1]
```

> __*a*__. $A'$ をBUBBLESORT(A)の出力とする. BUBBLESORTの正当性を証明するには，BUBBLESORTが停止し, 停止時に
>
> $A'[1] \le A'[2] \le \cdots \le A'[n]$  (2.3)
> 
> が成立することを証明しなければならない. ただし,  $ n=A. length $ である. BUBBLESORTが実際にソートをすることを証明するには他に何を証明する必要があるか?

* バブルソートが配列を正しくソートすることを証明するには、以下の2点が必要です：
1. **停止性**: アルゴリズムが有限のステップ後に終了すること。
2. **正当性**: アルゴリズムが終了時にソートされた配列を出力すること。すなわち、$A'[1] \le A'[2] \le \cdots \le A'[n]$ が成立すること。

* 加えて、**完全性**を示す必要があります。つまり、アルゴリズムがすべての入力に対して期待される動作をすること、また配列の要素が初期状態から順序のみが変更されることなく、同じ要素が保持されていることを示す必要があります。

> __*b*__. 第2-4行のfor文に対するループ不変式を正確に記述し，このループ不変式が成立することを証明せよ. ただし，本章で示したループ不変式の証明の構造に従って証明すること.

- **ループ不変式**: 各イテレーションの開始時に、部分配列 $A[j \ldots n]$ は $j$ が減少するにつれて増加する順序に並んでいる。

- **初期条件**: ループが開始する前の $j = n$ において、$A[n]$ は部分配列 $A[n \ldots n]$ の唯一の要素であるため、自動的にソートされた状態になります。従って、ループ不変式は真です。

- **ループ内条件**: ループの各ステップで $A[j] < A[j-1]$ の場合、$A[j]$ と $A[j-1]$ を交換します。これにより、$A[j]$ は次の位置に移動し、$A[j-1]$ とそれ以降の要素との間でソートされた順序を維持します。交換後も $A[j \ldots n]$ は増加する順序を保ちます。

- **終了条件**: ループが終了すると、$j = i + 1$ であり、この時点で $A[i]$ は $A[i \ldots n]$ の中で最小の要素になります。これは $A[i \ldots n]$ がソートされた状態を意味し、次の外側のループイテレーションの準備が整います。

> __*c*__. (b)で証明したループ不変式の停止条件を用いて, 不等式(2.3)の証明に繋がる, 第1-4行のfor文に対する)ループ不変式を記述せよ. ただし, 本章で示したループ不変式の証明の構造に従って証明すること.

- **ループ不変式**: 各イテレーションの開始時に、部分配列 $A[n-i+1 \ldots n]$ はソートされていて、これが配列の中で最大の要素を含んでいます。

- **初期条件**: 最初のイテレーション開始前（ $i=1$ ）、 $A[n]$ は考慮される部分配列 $A[n \ldots n]$ の唯一の要素です。この要素は単独でソートされていると見なされるため、ループ不変式は真です。

- **ループ内条件**: 各イテレーションで内側のループにより、 $A[n-i]$ が正しい位置に配置され、 $A[n-i+1 \ldots n]$ の要素はすでにソートされた状態を保っています。新たに $A[n-i]$ がこれに追加されることで、 $A[n-i \ldots n]$ もまたソートされた状態を保持します。

- **終了条件**: 外側のループが終了すると $i = n - 1$ であり、この時点で $A[1 \ldots n]$ 全体がソートされた状態になります。これは最終的に全配列がソートされることを意味し、バブルソートの正当性が証明されます。

> __*d*__. バブルソートの最悪実行時間を求めよ. 挿入ソートの実行時間と比較せよ. 

* バブルソートは配列が逆順に並んでいる場合に最悪のパフォーマンスを示し、最悪実行時間は $\Theta(n^2)$ です。この計算は、最初のパスで $n-1$ 回、次に $n-2$ 回、と減少していく比較と交換が行われることから導かれます。これは算術級数の和として、
$$
\frac{n(n-1)}{2}
$$
 と計算でき、$n^2$ のオーダーを持つことを示しています。

* 挿入ソートも最悪ケースで $\Theta(n^2)$ の実行時間を持ちますが、部分的にソートされた配列では非常に効率的に動作するため、実際の使用ではバブルソートよりも挿入ソートが好まれることが多いです。
* 特に、小規模なデータやほぼソート済みのデータでは、挿入ソートが顕著に速く動作することがあります。









### 2-3 Hornerの公式の正当性

> 次の擬似コード(の断片)は, 係数 $a_0, a_1, \cdots, a_n$ と $x$ の値が与えられたとき多項式
>
> $$\begin{matrix}
P(x) & = & \sum\limits_{k=0}^{n}a_{k} x^{k} \\\\
 & = & a_0 + x(a_1 + x(a_2 + \cdots + x(a_{n-1} + xa_n)\cdots))
\end{matrix}
$$
>
> の値を求めるためのHorner(ホーナー)の公式を実現したものである. 
>
> ```
> 1 y = 0
> 2 for i = n downto 0
> 3     y = ai + x y
>```

> __*a*__. Hornerの公式に対するこの擬似コードの実行時間を $\Theta$ 記法を用いて示せ.  

* $\Theta(n)$

> __*b*__. 多項式の各項を最初から計算する素朴な多項式評価のアルゴリズムの擬似コードを書け.
>
>　そのアルゴリズムの実行時間を求めよ. Hornerの公式と比較せよ. 

* 以下は素朴な多項式評価アルゴリズムのPython実装です。このアルゴリズムは、多項式の各項を個別に計算しています。

```python
def naive_poly_eval(A, x):
    sum = 0
    n = len(A) - 1
    for i in range(n + 1):
        term = A[i]
        for j in range(i):
            term *= x
        sum += term
    return sum
```

* 素朴な多項式評価のアルゴリズム：$\Theta(n^2)$
* Hornerの公式：$\Theta(n)$

> __*c*__. 次のループ不変式を考える. 
> 
> 　第2-3行のfor文の各繰返しの開始時点において
> 
> $y=\sum\limits_{k=0}^{n-(i+1)}a_{k+i+1} x^{k}$
>
> が成立する.
>
> 0個の項の和は0と解釈せよ. 本章で示したループ不変式の証明の構造に従って停止時に$\sum\limits_{k=0}^{n}a_{k} x^{k}$が成立することをループ不変式を用いて証明せよ.

- **初期条件** `y` が `0` に初期化されます。

- **ループ内条件** ループの各ステップで `y` は `y = a[i] + x * y` と更新されます。これを展開すると、

  $$ y = a_i + x \sum_{k=0}^{n-(i+1)} a_{k+i+1} x^k $$
  
  となり、これは
  
  $$ y = a_i x^0 + \sum_{k=0}^{n-(i+1)} a_{k+i+1} x^{k+1} $$
  
  さらに、これを再配置すると、
  
  $$ y = a_i x^0 + \sum_{k=1}^{n-i} a_{k+i} x^k $$

  となり、最終的に、

  $$ y = \sum_{k=0}^{n-i} a_{k+i} x^k $$

  が成立します。

- **終了条件** ループが終了するとき（`i = -1`の後）、`y` は

  $$ y = \sum_{k=0}^{n} a_k x^k $$

  となり、これは多項式 $P(x) = \sum_{k=0}^n a_k x^k$ の完全な形式に等しくなります。

> __*d*__. 与えた擬似コードが係数$a_0, a_1, \cdots, a_n$から定まる多項式の値を正しく計算することを結論せよ. 

- **ループ不変式**に基づき、各繰返しの開始時に `y` は部分的に計算された多項式の値を保持しています。
- ループ内で `y` に `x` を掛け、`a[i]` を加えることで、次の項を効率的に追加し、多項式の項が累積されていきます。
- ループが終了すると、`y` は完全な多項式 $P(x) = \sum_{k=0}^{n} a_k x^k$ の値と一致します。
- これにより、擬似コードは係数 $a_0, a_1, \cdots, a_n$ から定まる多項式の値を正確に計算すると結論付けられます。

### 2-4 反転

***

> $A[1..n]$ をn個の相異なる数の配列とする. $i < j$ かつ $A[i] > A[j]$ のとき, 対 $(i, j)$ を Aの反転(Inversion)と呼ぶ。

> __*a*__. 配列 $\left \langle 2, 3, 8, 6, 1 \right \rangle$ が含む5個の反転を列挙せよ.

* $(0, 4)$
* $(1, 4)$
* $(2, 3)$
* $(2, 4)$
* $(3, 4)$

> __*b*__. 集合$\\{1,2,\cdots,n\\}$から選択された要素を持つ配列の中で最も多くの反転を含むものを示せ. この配列が持つ反転数を求めよ.

* 全ての値を降順に並べた配列 $\left \langle n, n-1, ... , 3, 2, 1 \right \rangle$
* 反転数: $\frac{n(n-1)}{2}$

> __*c*__. 挿入ソートの実行時間と入力配列の反転数の関係を述べよ. 答が正しいことを証明せよ.

* 反転数) = 挿入ソート実行時の交換回数
* よって、入力配列の反転数が増加すると挿入ソートの実行時間も増加する。

> __*d*__. $n$ 個の要素からなる任意の順列が含む反転数を最悪時に$\Theta(n \lg n)$時間で決定するアルゴリズムを与えよ. (ヒント:マージソートを変形せよ.)


```python
def Merge(A, p, q, r):
    L = A[p:q+1]
    R = A[q+1:r+1]
    print('----------------------------------')
    print(A[p:q+1] , A[q+1:r+1]) # マージ前
    
    i = 0
    j = 0
    inversions = 0
    
    for k in range(p, r+1):
        if len(L) == i: # iはLの要素を参照するためのインデックスであるため、この条件でLの全ての要素がAに書かれたと判断できる
            A[k:r+1] = R[j:]
            break
            
        if len(R) == j: # jはRの要素を参照するためのインデックスであるため、この条件でRの全ての要素がAに書かれたと判断できる
            A[k:r+1] = L[i:]
            break
            
        if L[i] < R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
            inversions += (len(L) - i)
            
    print('↓MERGE↓')
    print(A[p:q+1] + A[q+1:r+1]) # マージ後
    return inversions
    

def Merge_sort(A, p, r):
    inversions = 0
    if p < r:
        q = (p+r) // 2
        inversions += Merge_sort(A, p, q)        
        inversions +=Merge_sort(A, q+1, r)
        inversions += Merge(A, p, q, r)
        print('反転数：', inversions)
        
    return inversions
```


```python
A = [2, 3, 8, 6, 1]
count = Merge_sort(A, 0, len(A)-1)
print(count)
```

    ----------------------------------
    [2] [3]
    ↓MERGE↓
    [2, 3]
    反転数： 0
    ----------------------------------
    [2, 3] [8]
    ↓MERGE↓
    [2, 3, 8]
    反転数： 0
    ----------------------------------
    [6] [1]
    ↓MERGE↓
    [1, 6]
    反転数： 1
    ----------------------------------
    [2, 3, 8] [1, 6]
    ↓MERGE↓
    [1, 2, 3, 6, 8]
    反転数： 5
    5

